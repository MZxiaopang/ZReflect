静态代理优缺点:
优点：业务类只需要关注业务逻辑本身，保证了业务类的重用性。
缺点：
?1.代理对象的某个接口只服务于某一种类型的对象，也就是说每一个真实对象都得创建一个代理对象。
?2.如果需要代理的方法很多，则要为每一种方法都进行代理处理。 
?3.如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。


动态代理类是在程序运行期间由JVM通过反射等机制动态的生成的，所以不存在代理类的字节码文件。代理对象和真实对象的关系是在程序运行事情才确定的。
JDK动态代理API分析:
1、java.lang.reflect.Proxy 类:
Java 动态代理机制生成的所有动态代理类的父类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象。 
主要方法：
public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,InvocationHandler hanlder)
方法职责：为指定类加载器、一组接口及调用处理器生成动态代理类实例 
参数:
   loader		:类加载器
   interfaces	:模拟的接口
   hanlder		:代理执行处理器


返回:动态生成的代理对象
2、java.lang.reflect.InvocationHandler接口:
public Object invoke(Object proxy, Method method, Object[] args)
方法职责：负责集中处理动态代理类上的所有方法调用
参数: 
    proxy	:生成的代理对象
    method	:当前调用的真实方法对象
	args	:当前调用方法的实参


返回: 真实方法的返回结果
------------------------------------------------------------------------------------
?jdk动态代理操作步骤 
①　实现InvocationHandler接口，创建自己增强代码的处理器。
②　给Proxy类提供ClassLoader对象和代理接口类型数组，创建动态代理对象。
③　在处理器中实现增强操作。

Spring AOP:面向切面编程
代理的最小范围是方法，可以针对指定类或指定名称的方法进行代理，支持通配符add*()。
Aop的概念：
  1：切入点：          （在烧饼的什么地方切开）：在哪些类，那些方法上切入其他代码（功能增强）
  2：增强（通知）：（需要放到烧饼中的肉）在执行原有的方法的什么时候（方法前，方法后）要去做什么（插入需要增加的代码）
  3：切面：               切入点+增强  在哪些类，那些方法执行的过程中插入需要增加的代码
  4：织入：（将肉放到烧饼中的过程），把切面加入到对象中，并且创建出代理对象的过程（该过程由Spring自动完成）

AOP的实现有两种：
1：xml实现

2：注解实现
















