单例：让类只能产生一个实例对象
为什么要用：如果不使用单例的情况下，假如我们在项目中new了100个对象，有1000人访问1次
就会产生10w对象，如果1000个人 每人访问1w次的话，会产生10亿个对象，当对象过多，每个对象都要占据空间，
容易造成内存溢出（内存不够用了）。
如果使用单例模式设计。这100个类，保证无论多少人访问多少次永远都是100个对象
不会造成内存溢出。

单例：等于系统优化
	
	所有的单例模式第一步都是私有化构造器，让外部无法访问

一：饿汉式
	1：// 优点：写法简单，线程安全，因为被static修饰的成员在内存中永远只有一个，所以线程安全
	   // 缺点，当调用类中其他静态成员的时候，会自动创建对象，哪怕你根本就不使用这个对象的资源
	   // 被static修饰的在内存中永远只有一个,线程安全
	2：// 优点: 写法简单，线程安全，因为被static修饰的成员在内存中永远只有一个，
	   // 所以线程安全,静态内部类不会与静态成员同时被加载，而是在调用的时候才会被加载
	   // 所以解决了之前，内存占用的问题
	  // 缺点:无
	  // 被static修饰的在内存中永远只有一个,线程安全
二：懒汉式
	1：// 优点：在开始的时候不进行对象的创建，而是在需要的使用对象的时候
	   // 在进行对象的创建 对内存来说比较优化
	   // 缺点：线程不安全 当多线程并发的时候，可能会有多个线程同时进入到if判断中

	2：// 优点：在开始的时候不进行对象的创建，而是在需要的使用对象的时候
	// 在进行对象的创建 对内存来说比较优化，加入synchronized后线程变得安全
	// 缺点：多线程完全失效，永远只有一个线程能执行这个方法，效率低下。

	3：// 优点：在开始的时候不进行对象的创建，而是在需要的使用对象的时候
	// 在进行对象的创建 对内存来说比较优化，加入synchronized后线程变得安全,使用双重if判断
	// 让线程只有第一次执行的时候才有可能进入到线程锁的代码块排队,来实现改善效率
	// 缺点：多线程完全失效，永远只有一个线程能执行这个方法，效率低下。





